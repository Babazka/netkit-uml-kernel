===============================================================================

This patch introduces a number of hooks to IPv4 and IPv6 kernel modules.
These hooks allow tracking various events relevant to network layer, such as
packet creation, recieving and transmitting, fragmentation and reassembly,
filtering and address translation.

The patch exports following functions:

  void ipevents_set_handler(ipevents_eventhandler_fn handler);
  void ipevents_reset_handler(void);
  
The first one can be called with a pointer to an event handler function, like
this one:

void my_event_handler(unsigned int hook, unsigned int event, 
     struct sk_buff *skb,  struct net_device *dev, void *arg) {
    printk(KERN_INFO "Something happened to packet 0x%08X\n", skb);
}

`hook` argument specifies in which function the event happened
       (see enum ipevents_hooks below);
`event` specifies location within the function (see enum possible_ipevents).

TECHNICAL INFORMATION:

Applies to kernel 2.6.26.5.

===============================================================================

diff --git a/arch/um/include/mconsole.h b/arch/um/include/mconsole.h
index c139ae1..0096797 100644
--- a/arch/um/include/mconsole.h
+++ b/arch/um/include/mconsole.h
@@ -95,4 +95,6 @@ extern char *mconsole_notify_socket(void);
 extern void lock_notify(void);
 extern void unlock_notify(void);
 
+extern void mconsole_direct_notify(char *buf, int count);
+
 #endif
diff --git a/include/linux/ipevents.h b/include/linux/ipevents.h
new file mode 100644
index 0000000..1db814b
--- /dev/null
+++ b/include/linux/ipevents.h
@@ -0,0 +1,82 @@
+#ifndef __LINUX_IPEVENTS_H
+#define __LINUX_IPEVENTS_H
+
+#ifdef __KERNEL__
+#include <linux/init.h>
+#include <linux/skbuff.h>
+#include <linux/net.h>
+#include <linux/netfilter.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+#endif
+#include <linux/types.h>
+#include <linux/compiler.h>
+
+#define MY_OWN_HOOK (1 << 30)
+
+enum ipevents_hooks {
+    IPE_INET_PRE_ROUTING        = NF_INET_PRE_ROUTING,
+    IPE_INET_LOCAL_IN           = NF_INET_LOCAL_IN,
+    IPE_INET_FORWARD            = NF_INET_FORWARD,
+    IPE_INET_LOCAL_OUT          = NF_INET_LOCAL_OUT,
+    IPE_INET_POST_ROUTING       = NF_INET_POST_ROUTING,
+    IPE_KFREE_SKB               = MY_OWN_HOOK | 1,
+    IPE_IP_RCV                  = MY_OWN_HOOK | 2,
+    IPE_IP_RCV_FINISH           = MY_OWN_HOOK | 3,
+    IPE_IP_FINISH_OUTPUT        = MY_OWN_HOOK | 4,
+    IPE_IP_FINISH_OUTPUT2       = MY_OWN_HOOK | 5,
+    IPE_IP_FORWARD              = MY_OWN_HOOK | 6,
+    IPE_IP_LOCAL_OUT            = MY_OWN_HOOK | 7,
+    IPE_IP_LOCAL_DELIVER        = MY_OWN_HOOK | 8,
+    IPE_IP_LOCAL_DELIVER_FINISH = MY_OWN_HOOK | 9,
+    IPE_IP_DEFRAG               = MY_OWN_HOOK | 10,
+    IPE_IP_FRAG_REASM           = MY_OWN_HOOK | 11,
+    IPE_IP_FRAGMENT             = MY_OWN_HOOK | 12,
+    IPE_ICMP_SEND               = MY_OWN_HOOK | 13,
+    IPE_IP_MR_FORWARD           = MY_OWN_HOOK | 14,
+};
+
+enum possible_ipevents {
+    IPE_GENERIC = 0, /* first four */
+    IPE_BEFORE,      /*   are used */
+    IPE_AFTER,       /*  in actual */
+    IPE_DROPPED,     /*    hooks   */
+    
+    IPE_NAT_DETECTED,  /* this one is used as basis for IPE_NAT_* event types 
+                        * (see below) */
+};
+
+#define IPE_NAT_ADDRESS (1 << 10)
+#define IPE_NAT_PORT (1 << 12)
+#define IPE_NAT_SRC (1 << 13)
+#define IPE_NAT_DST (1 << 14)
+#define IPE_NAT_V6 (1 << 11)
+
+/* event type value for NAT events is composed by performing bitwise OR of
+ * IPE_NAT_DETECTED, IPE_NAT_PORT/ADDRESS and IPE_NAT_SRC/DST
+ * with additional OR with IPE_NAT_V6 if IPv6 is used.
+ * 
+ * Keep in mind that a single NAT event is either ADDRESS or PORT, and
+ * either SRC or DST, but not both.
+ * 
+ * Yes, it could be done with just bits 10-12 instead of 10-14,
+ * but I'm lazy.
+*/
+
+typedef void (*ipevents_eventhandler_fn)(unsigned int hook, unsigned int event, 
+                                      struct sk_buff *skb,
+                                      struct net_device *dev,
+			                          void *arg);
+			                          
+extern void ipevents_set_handler(ipevents_eventhandler_fn handler);
+extern void ipevents_reset_handler(void);					                          
+			                         
+
+
+extern void ipevents_event(unsigned int hook, unsigned int event, 
+                    struct sk_buff *skb,
+                    struct net_device *dev,
+				    void *arg);
+
+
+#endif
diff --git a/net/Makefile b/net/Makefile
index 53e3967..0ebf524 100644
--- a/net/Makefile
+++ b/net/Makefile
@@ -55,6 +55,8 @@ obj-$(CONFIG_IUCV)		+= iucv/
 obj-$(CONFIG_RFKILL)		+= rfkill/
 obj-$(CONFIG_NET_9P)		+= 9p/
 
+obj-y				+= ipevents_kern.o
+
 ifeq ($(CONFIG_NET),y)
 obj-$(CONFIG_SYSCTL)		+= sysctl_net.o
 endif
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 3666216..4a8f2eb 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -67,6 +67,8 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
+#include <linux/ipevents.h>
+
 #include "kmap_skb.h"
 
 static struct kmem_cache *skbuff_head_cache __read_mostly;
@@ -423,6 +425,7 @@ void kfree_skb(struct sk_buff *skb)
 		smp_rmb();
 	else if (likely(!atomic_dec_and_test(&skb->users)))
 		return;
+	ipevents_event(IPE_KFREE_SKB, IPE_DROPPED, skb, NULL, NULL);
 	__kfree_skb(skb);
 }
 
diff --git a/net/ipevents_kern.c b/net/ipevents_kern.c
new file mode 100644
index 0000000..d5a0681
--- /dev/null
+++ b/net/ipevents_kern.c
@@ -0,0 +1,43 @@
+/*
+ *  ipevents: inner kernel part
+ *
+ * Copyright 2011 Kryuchkov Alexey
+ *
+*/  
+#include <linux/if_ether.h>
+#include <linux/ipevents.h>
+
+static ipevents_eventhandler_fn ipevents_eventhandler = NULL;
+
+void ipevents_set_handler(ipevents_eventhandler_fn handler)
+{
+    /* write-lock here */
+    ipevents_eventhandler = handler;
+    /* write-unlock here */
+}
+EXPORT_SYMBOL(ipevents_set_handler);
+
+void ipevents_reset_handler(void)
+{
+    /* write-lock here */
+    ipevents_eventhandler = NULL;
+    /* write-unlock here */
+}
+EXPORT_SYMBOL(ipevents_reset_handler);
+
+void ipevents_event(unsigned int hook, unsigned int event, 
+                    struct sk_buff *skb,
+                    struct net_device *dev,
+				    void *arg)
+{
+    uint32_t ethertype = ntohs(skb->protocol);
+    if (unlikely(ethertype != ETH_P_IP && ethertype != ETH_P_IPV6)) 
+        return;
+    /* read-lock here */
+    if (ipevents_eventhandler)
+        ipevents_eventhandler(hook, event, skb, dev, arg);
+    /* read-unlock here */
+}
+
+/* due to IPv6 residing in a separate module, we have to export this */
+EXPORT_SYMBOL(ipevents_event);
diff --git a/net/ipv4/icmp.c b/net/ipv4/icmp.c
index 8739735..9db9a9b 100644
--- a/net/ipv4/icmp.c
+++ b/net/ipv4/icmp.c
@@ -95,6 +95,9 @@
 #include <net/xfrm.h>
 #include <net/inet_common.h>
 
+
+#include <linux/ipevents.h>
+
 /*
  *	Build xmit assembly blocks
  */
@@ -428,7 +431,9 @@ void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)
 		goto out;
 	net = dev_net(rt->u.dst.dev);
 	sk = icmp_sk(net);
-
+	
+	ipevents_event(IPE_ICMP_SEND, IPE_GENERIC, skb_in, NULL, (void*) ((code << 8) | type));
+	
 	/*
 	 *	Find the original header. It is expected to be valid, of course.
 	 *	Check this, icmp_send is called from the most obscure devices
diff --git a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c
index 4813c39..57644d8 100644
--- a/net/ipv4/ip_forward.c
+++ b/net/ipv4/ip_forward.c
@@ -40,6 +40,9 @@
 #include <net/route.h>
 #include <net/xfrm.h>
 
+
+#include <linux/ipevents.h>
+
 static int ip_forward_finish(struct sk_buff *skb)
 {
 	struct ip_options * opt	= &(IPCB(skb)->opt);
@@ -48,6 +51,7 @@ static int ip_forward_finish(struct sk_buff *skb)
 
 	if (unlikely(opt->optlen))
 		ip_forward_options(skb);
+		
 
 	return dst_output(skb);
 }
@@ -58,6 +62,8 @@ int ip_forward(struct sk_buff *skb)
 	struct rtable *rt;	/* Route we use */
 	struct ip_options * opt	= &(IPCB(skb)->opt);
 
+
+
 	if (!xfrm4_policy_check(NULL, XFRM_POLICY_FWD, skb))
 		goto drop;
 
@@ -100,6 +106,8 @@ int ip_forward(struct sk_buff *skb)
 
 	/* Decrease ttl after skb cow done */
 	ip_decrease_ttl(iph);
+	
+	ipevents_event(IPE_IP_FORWARD, IPE_GENERIC, skb, NULL, NULL);
 
 	/*
 	 *	We now generate an ICMP HOST REDIRECT giving the route
@@ -125,6 +133,7 @@ too_many_hops:
 	IP_INC_STATS_BH(IPSTATS_MIB_INHDRERRORS);
 	icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);
 drop:
+	ipevents_event(IPE_IP_FORWARD, IPE_DROPPED, skb, NULL, NULL);
 	kfree_skb(skb);
 	return NET_RX_DROP;
 }
diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c
index 37221f6..5b68467 100644
--- a/net/ipv4/ip_fragment.c
+++ b/net/ipv4/ip_fragment.c
@@ -45,6 +45,9 @@
 #include <linux/inet.h>
 #include <linux/netfilter_ipv4.h>
 
+
+#include <linux/ipevents.h>
+
 /* NOTE. Logic of IP defragmentation is parallel to corresponding IPv6
  * code now. If you change something here, _PLEASE_ update ipv6/reassembly.c
  * as well. Or notify me, at least. --ANK
@@ -463,13 +466,21 @@ static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,
 			 struct net_device *dev)
 {
 	struct iphdr *iph;
-	struct sk_buff *fp, *head = qp->q.fragments;
+	struct sk_buff *fp, *iter, *head = qp->q.fragments;
 	int len;
 	int ihlen;
 	int err;
 
 	ipq_kill(qp);
-
+	
+	if (prev)
+		head = prev->next;
+	
+	for (iter=qp->q.fragments; iter; iter = iter->next) {
+		ipevents_event(IPE_IP_FRAG_REASM, IPE_BEFORE, iter, NULL, (void*)head);
+	}
+	
+	
 	/* Make the one we just received the head. */
 	if (prev) {
 		head = prev->next;
@@ -489,6 +500,7 @@ static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,
 
 	BUG_TRAP(head != NULL);
 	BUG_TRAP(FRAG_CB(head)->offset == 0);
+	
 
 	/* Allocate a new buffer for the datagram. */
 	ihlen = ip_hdrlen(head);
@@ -501,6 +513,7 @@ static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,
 	/* Head of list must not be cloned. */
 	if (skb_cloned(head) && pskb_expand_head(head, 0, 0, GFP_ATOMIC))
 		goto out_nomem;
+		
 
 	/* If the first fragment is fragmented itself, we split
 	 * it to two chunks: the first with data and paged part
@@ -539,6 +552,8 @@ static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,
 		head->truesize += fp->truesize;
 		atomic_sub(fp->truesize, &qp->q.net->mem);
 	}
+	
+	ipevents_event(IPE_IP_FRAG_REASM, IPE_AFTER, head, NULL, NULL);
 
 	head->next = NULL;
 	head->dev = dev;
@@ -549,6 +564,7 @@ static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,
 	iph->tot_len = htons(len);
 	IP_INC_STATS_BH(IPSTATS_MIB_REASMOKS);
 	qp->q.fragments = NULL;
+	
 	return 0;
 
 out_nomem:
@@ -579,6 +595,8 @@ int ip_defrag(struct sk_buff *skb, u32 user)
 	if (atomic_read(&net->ipv4.frags.mem) > net->ipv4.frags.high_thresh)
 		ip_evictor(net);
 
+	ipevents_event(IPE_IP_DEFRAG, IPE_BEFORE, skb, NULL, NULL);
+
 	/* Lookup (or create) queue header */
 	if ((qp = ip_find(net, ip_hdr(skb), user)) != NULL) {
 		int ret;
@@ -593,6 +611,7 @@ int ip_defrag(struct sk_buff *skb, u32 user)
 	}
 
 	IP_INC_STATS_BH(IPSTATS_MIB_REASMFAILS);
+	ipevents_event(IPE_IP_DEFRAG, IPE_DROPPED, skb, NULL, NULL);
 	kfree_skb(skb);
 	return -ENOMEM;
 }
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index f34b637..c95685b 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -146,6 +146,8 @@
 #include <linux/mroute.h>
 #include <linux/netlink.h>
 
+#include <linux/ipevents.h>
+
 /*
  *	SNMP management statistics
  */
@@ -202,10 +204,12 @@ static int ip_local_deliver_finish(struct sk_buff *skb)
 	struct net *net = dev_net(skb->dev);
 
 	__skb_pull(skb, ip_hdrlen(skb));
-
+	
 	/* Point into the IP datagram, just past the header. */
 	skb_reset_transport_header(skb);
-
+	
+	ipevents_event(IPE_IP_LOCAL_DELIVER_FINISH, IPE_GENERIC, skb, NULL, NULL);
+	
 	rcu_read_lock();
 	{
 		int protocol = ip_hdr(skb)->protocol;
@@ -214,12 +218,12 @@ static int ip_local_deliver_finish(struct sk_buff *skb)
 
 	resubmit:
 		raw = raw_local_deliver(skb, protocol);
-
+		
 		hash = protocol & (MAX_INET_PROTOS - 1);
 		ipprot = rcu_dereference(inet_protos[hash]);
 		if (ipprot != NULL && (net == &init_net || ipprot->netns_ok)) {
 			int ret;
-
+			
 			if (!ipprot->no_policy) {
 				if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
 					kfree_skb(skb);
@@ -227,11 +231,13 @@ static int ip_local_deliver_finish(struct sk_buff *skb)
 				}
 				nf_reset(skb);
 			}
+			
 			ret = ipprot->handler(skb);
 			if (ret < 0) {
 				protocol = -ret;
 				goto resubmit;
 			}
+			ipevents_event(IPE_IP_LOCAL_DELIVER_FINISH, IPE_AFTER, skb, NULL, NULL);
 			IP_INC_STATS_BH(IPSTATS_MIB_INDELIVERS);
 		} else {
 			if (!raw) {
@@ -240,8 +246,10 @@ static int ip_local_deliver_finish(struct sk_buff *skb)
 					icmp_send(skb, ICMP_DEST_UNREACH,
 						  ICMP_PROT_UNREACH, 0);
 				}
-			} else
+			} else {
+				ipevents_event(IPE_IP_LOCAL_DELIVER_FINISH, IPE_AFTER, skb, NULL, NULL);
 				IP_INC_STATS_BH(IPSTATS_MIB_INDELIVERS);
+		    }
 			kfree_skb(skb);
 		}
 	}
@@ -256,6 +264,8 @@ static int ip_local_deliver_finish(struct sk_buff *skb)
  */
 int ip_local_deliver(struct sk_buff *skb)
 {
+	ipevents_event(IPE_IP_LOCAL_DELIVER, IPE_GENERIC, skb, NULL, NULL);
+	
 	/*
 	 *	Reassemble IP fragments.
 	 */
@@ -366,6 +376,7 @@ static int ip_rcv_finish(struct sk_buff *skb)
 	return dst_input(skb);
 
 drop:
+	ipevents_event(IPE_IP_RCV_FINISH, IPE_DROPPED, skb, NULL, NULL);
 	kfree_skb(skb);
 	return NET_RX_DROP;
 }
@@ -393,8 +404,12 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
 
 	if (!pskb_may_pull(skb, sizeof(struct iphdr)))
 		goto inhdr_error;
+		
+	ipevents_event(IPE_IP_RCV, IPE_GENERIC, skb, dev, NULL);
 
 	iph = ip_hdr(skb);
+	
+	/*printk(KERN_INFO "[ipstalker] ip_recv (%s),(%s)\n", dev->name, orig_dev->name); TODO*/
 
 	/*
 	 *	RFC1122: 3.2.1.2 MUST silently discard any IP frame that fails the checksum.
@@ -443,6 +458,7 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
 inhdr_error:
 	IP_INC_STATS_BH(IPSTATS_MIB_INHDRERRORS);
 drop:
+	ipevents_event(IPE_IP_RCV, IPE_DROPPED, skb, dev, NULL);
 	kfree_skb(skb);
 out:
 	return NET_RX_DROP;
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 7ca48e4..57e92e4 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -82,6 +82,9 @@
 #include <linux/netlink.h>
 #include <linux/tcp.h>
 
+
+#include <linux/ipevents.h>
+
 int sysctl_ip_default_ttl __read_mostly = IPDEFTTL;
 
 /* Generate a checksum for an outgoing IP datagram. */
@@ -91,6 +94,8 @@ __inline__ void ip_send_check(struct iphdr *iph)
 	iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
 }
 
+/*static uint16_t id_for_ip = 1;*/
+
 int __ip_local_out(struct sk_buff *skb)
 {
 	struct iphdr *iph = ip_hdr(skb);
@@ -104,7 +109,13 @@ int __ip_local_out(struct sk_buff *skb)
 int ip_local_out(struct sk_buff *skb)
 {
 	int err;
+	struct iphdr *iph = ip_hdr(skb);
+	
+	skb->protocol = htons(ETH_P_IP);
+	/*iph->id = htons(id_for_ip++); HACK */
 
+	ipevents_event(IPE_IP_LOCAL_OUT, IPE_GENERIC, skb, NULL, NULL);
+	
 	err = __ip_local_out(skb);
 	if (likely(err == 1))
 		err = dst_output(skb);
@@ -183,6 +194,7 @@ static inline int ip_finish_output2(struct sk_buff *skb)
 	struct net_device *dev = dst->dev;
 	unsigned int hh_len = LL_RESERVED_SPACE(dev);
 
+
 	if (rt->rt_type == RTN_MULTICAST)
 		IP_INC_STATS(IPSTATS_MIB_OUTMCASTPKTS);
 	else if (rt->rt_type == RTN_BROADCAST)
@@ -190,6 +202,7 @@ static inline int ip_finish_output2(struct sk_buff *skb)
 
 	if (dst->child) {
 		skb->dst = dst_pop(skb->dst);
+		ipevents_event(IPE_IP_FINISH_OUTPUT2, IPE_GENERIC, skb, skb->dst->dev, NULL);
 		return dst_output(skb);
 	}
 
@@ -202,19 +215,30 @@ static inline int ip_finish_output2(struct sk_buff *skb)
 			kfree_skb(skb);
 			return -ENOMEM;
 		}
+		
 		if (skb->sk)
 			skb_set_owner_w(skb2, skb->sk);
+		
+		/* This is crazy! Better tell ipevents that all is OK  *
+		 * than deal with pointer change                       */
+		
+		ipevents_event(IPE_IP_FINISH_OUTPUT2, IPE_GENERIC, skb, dev, NULL);
+		
 		kfree_skb(skb);
 		skb = skb2;
 	}
 
-	if (dst->hh)
-		return neigh_hh_output(dst->hh, skb);
-	else if (dst->neighbour)
-		return dst->neighbour->output(skb);
+	if (dst->hh || dst->neighbour) {
+		ipevents_event(IPE_IP_FINISH_OUTPUT2, IPE_GENERIC, skb, dev, NULL);
+		if (dst->hh)
+			return neigh_hh_output(dst->hh, skb);
+		else if (dst->neighbour)
+			return dst->neighbour->output(skb);
+	}
 
 	if (net_ratelimit())
 		printk(KERN_DEBUG "ip_finish_output2: No header cache and no neighbour!\n");
+	ipevents_event(IPE_IP_FINISH_OUTPUT2, IPE_DROPPED, skb, NULL, NULL);
 	kfree_skb(skb);
 	return -EINVAL;
 }
@@ -236,6 +260,9 @@ static int ip_finish_output(struct sk_buff *skb)
 		return dst_output(skb);
 	}
 #endif
+	
+	ipevents_event(IPE_IP_FINISH_OUTPUT, IPE_GENERIC, skb, NULL, NULL);
+	
 	if (skb->len > ip_skb_dst_mtu(skb) && !skb_is_gso(skb))
 		return ip_fragment(skb, ip_finish_output2);
 	else
@@ -309,7 +336,7 @@ int ip_output(struct sk_buff *skb)
 
 	skb->dev = dev;
 	skb->protocol = htons(ETH_P_IP);
-
+	
 	return NF_HOOK_COND(PF_INET, NF_INET_POST_ROUTING, skb, NULL, dev,
 			    ip_finish_output,
 			    !(IPCB(skb)->flags & IPSKB_REROUTED));
@@ -443,12 +470,15 @@ int ip_fragment(struct sk_buff *skb, int (*output)(struct sk_buff*))
 	int ptr;
 	struct net_device *dev;
 	struct sk_buff *skb2;
+	struct sk_buff *original_skb = skb;
 	unsigned int mtu, hlen, left, len, ll_rs, pad;
 	int offset;
 	__be16 not_last_frag;
 	struct rtable *rt = skb->rtable;
 	int err = 0;
 
+	ipevents_event(IPE_IP_FRAGMENT, IPE_BEFORE, skb, NULL, NULL);
+
 	dev = rt->u.dst.dev;
 
 	/*
@@ -545,7 +575,8 @@ int ip_fragment(struct sk_buff *skb, int (*output)(struct sk_buff*))
 				/* Ready, complete checksum */
 				ip_send_check(iph);
 			}
-
+			
+			ipevents_event(IPE_IP_FRAGMENT, IPE_GENERIC, skb, NULL, (void*)original_skb);
 			err = output(skb);
 
 			if (!err)
@@ -560,6 +591,7 @@ int ip_fragment(struct sk_buff *skb, int (*output)(struct sk_buff*))
 
 		if (err == 0) {
 			IP_INC_STATS(IPSTATS_MIB_FRAGOKS);
+			ipevents_event(IPE_IP_FRAGMENT, IPE_AFTER, original_skb, NULL, NULL);
 			return 0;
 		}
 
@@ -675,13 +707,15 @@ slow_path:
 		iph->tot_len = htons(len + hlen);
 
 		ip_send_check(iph);
-
+		
+		ipevents_event(IPE_IP_FRAGMENT, IPE_GENERIC, skb2, NULL, (void*)original_skb);
 		err = output(skb2);
 		if (err)
 			goto fail;
 
 		IP_INC_STATS(IPSTATS_MIB_FRAGCREATES);
 	}
+	ipevents_event(IPE_IP_FRAGMENT, IPE_AFTER, original_skb, NULL, NULL);
 	kfree_skb(skb);
 	IP_INC_STATS(IPSTATS_MIB_FRAGOKS);
 	return err;
diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c
index 11700a4..2ad8fd6 100644
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -65,6 +65,8 @@
 #include <net/checksum.h>
 #include <net/netlink.h>
 
+#include <linux/ipevents.h>
+
 #if defined(CONFIG_IP_PIMSM_V1) || defined(CONFIG_IP_PIMSM_V2)
 #define CONFIG_IP_PIMSM	1
 #endif
@@ -1315,6 +1317,8 @@ static int ip_mr_forward(struct sk_buff *skb, struct mfc_cache *cache, int local
 		}
 		goto dont_forward;
 	}
+	
+	ipevents_event(IPE_IP_MR_FORWARD, IPE_BEFORE, skb, NULL, NULL);
 
 	vif_table[vif].pkt_in++;
 	vif_table[vif].bytes_in+=skb->len;
@@ -1326,8 +1330,10 @@ static int ip_mr_forward(struct sk_buff *skb, struct mfc_cache *cache, int local
 		if (ip_hdr(skb)->ttl > cache->mfc_un.res.ttls[ct]) {
 			if (psend != -1) {
 				struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);
-				if (skb2)
+				if (skb2) {
+					ipevents_event(IPE_IP_MR_FORWARD, IPE_GENERIC, skb2, NULL, (void*)skb);
 					ipmr_queue_xmit(skb2, cache, psend);
+				}
 			}
 			psend=ct;
 		}
@@ -1335,17 +1341,28 @@ static int ip_mr_forward(struct sk_buff *skb, struct mfc_cache *cache, int local
 	if (psend != -1) {
 		if (local) {
 			struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);
-			if (skb2)
+			if (skb2) {
+				ipevents_event(IPE_IP_MR_FORWARD, IPE_GENERIC, skb2, NULL, (void*)skb);
 				ipmr_queue_xmit(skb2, cache, psend);
+			}
 		} else {
+			ipevents_event(IPE_IP_MR_FORWARD, IPE_GENERIC, skb, NULL, (void*)skb);
 			ipmr_queue_xmit(skb, cache, psend);
+			ipevents_event(IPE_IP_MR_FORWARD, IPE_AFTER, skb, NULL, NULL);
 			return 0;
 		}
 	}
 
 dont_forward:
-	if (!local)
+	if (!local) {
+		/* no more copies */
+		ipevents_event(IPE_IP_MR_FORWARD, IPE_AFTER, skb, NULL, NULL);
 		kfree_skb(skb);
+	} else {
+		/* skb will be the last copy of itself */
+		ipevents_event(IPE_IP_MR_FORWARD, IPE_GENERIC, skb, NULL, (void*)skb);
+		ipevents_event(IPE_IP_MR_FORWARD, IPE_AFTER, skb, NULL, NULL);
+	}
 	return 0;
 }
 
diff --git a/net/ipv6/icmp.c b/net/ipv6/icmp.c
index d42dd16..ccb445d 100644
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@ -69,6 +69,8 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
+#include <linux/ipevents.h>
+
 DEFINE_SNMP_STAT(struct icmpv6_mib, icmpv6_statistics) __read_mostly;
 EXPORT_SYMBOL(icmpv6_statistics);
 DEFINE_SNMP_STAT(struct icmpv6msg_mib, icmpv6msg_statistics) __read_mostly;
@@ -328,7 +330,9 @@ void icmpv6_send(struct sk_buff *skb, int type, int code, __u32 info,
 	if ((u8 *)hdr < skb->head ||
 	    (skb->network_header + sizeof(*hdr)) > skb->tail)
 		return;
-
+    
+    ipevents_event(IPE_ICMP_SEND, IPE_GENERIC, skb, NULL, (void*) ((code << 8) | type));
+    
 	/*
 	 *	Make sure we respect the rules
 	 *	i.e. RFC 1885 2.4(e)
diff --git a/net/ipv6/ip6_input.c b/net/ipv6/ip6_input.c
index d44a723..56e04e8 100644
--- a/net/ipv6/ip6_input.c
+++ b/net/ipv6/ip6_input.c
@@ -46,12 +46,18 @@
 #include <net/addrconf.h>
 #include <net/xfrm.h>
 
+#include <linux/ipevents.h>
+
 
 
 inline int ip6_rcv_finish( struct sk_buff *skb)
 {
+	ipevents_event(IPE_IP_RCV_FINISH, IPE_GENERIC, skb, NULL, NULL);
+	
 	if (skb->dst == NULL)
 		ip6_route_input(skb);
+	
+	
 
 	return dst_input(skb);
 }
@@ -96,7 +102,9 @@ int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt
 
 	if (unlikely(!pskb_may_pull(skb, sizeof(*hdr))))
 		goto err;
-
+	
+	ipevents_event(IPE_IP_RCV, IPE_GENERIC, skb, dev, NULL);
+	
 	hdr = ipv6_hdr(skb);
 
 	if (hdr->version != 6)
@@ -144,6 +152,7 @@ int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt
 err:
 	IP6_INC_STATS_BH(idev, IPSTATS_MIB_INHDRERRORS);
 drop:
+	ipevents_event(IPE_IP_RCV, IPE_DROPPED, skb, dev, NULL);
 	rcu_read_unlock();
 	kfree_skb(skb);
 out:
@@ -168,6 +177,9 @@ static int ip6_input_finish(struct sk_buff *skb)
 	 */
 
 	rcu_read_lock();
+	
+	
+	
 resubmit:
 	idev = ip6_dst_idev(skb->dst);
 	if (!pskb_pull(skb, skb_transport_offset(skb)))
@@ -183,7 +195,9 @@ resubmit:
 
 		if (ipprot->flags & INET6_PROTO_FINAL) {
 			struct ipv6hdr *hdr;
-
+			
+            ipevents_event(IPE_IP_LOCAL_DELIVER_FINISH, IPE_GENERIC, skb, NULL, NULL);
+            
 			/* Free reference early: we don't need it any more,
 			   and it may hold ip_conntrack module loaded
 			   indefinitely. */
@@ -205,8 +219,10 @@ resubmit:
 		ret = ipprot->handler(skb);
 		if (ret > 0)
 			goto resubmit;
-		else if (ret == 0)
+		else if (ret == 0) {
+			ipevents_event(IPE_IP_LOCAL_DELIVER_FINISH, IPE_AFTER, skb, NULL, NULL);
 			IP6_INC_STATS_BH(idev, IPSTATS_MIB_INDELIVERS);
+		}
 	} else {
 		if (!raw) {
 			if (xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {
@@ -215,8 +231,10 @@ resubmit:
 					    ICMPV6_UNK_NEXTHDR, nhoff,
 					    skb->dev);
 			}
-		} else
+		} else {
+			ipevents_event(IPE_IP_LOCAL_DELIVER_FINISH, IPE_AFTER, skb, NULL, NULL);
 			IP6_INC_STATS_BH(idev, IPSTATS_MIB_INDELIVERS);
+		}
 		kfree_skb(skb);
 	}
 	rcu_read_unlock();
@@ -232,6 +250,8 @@ discard:
 
 int ip6_input(struct sk_buff *skb)
 {
+	ipevents_event(IPE_IP_LOCAL_DELIVER, IPE_GENERIC, skb, NULL, NULL);
+	
 	return NF_HOOK(PF_INET6, NF_INET_LOCAL_IN, skb, skb->dev, NULL,
 		       ip6_input_finish);
 }
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 546e101..54bc543 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -57,6 +57,8 @@
 #include <net/checksum.h>
 #include <linux/mroute6.h>
 
+#include <linux/ipevents.h>
+
 static int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *));
 
 static __inline__ void ipv6_select_ident(struct sk_buff *skb, struct frag_hdr *fhdr)
@@ -87,6 +89,9 @@ int __ip6_local_out(struct sk_buff *skb)
 int ip6_local_out(struct sk_buff *skb)
 {
 	int err;
+	
+	skb->protocol = htons(ETH_P_IPV6);
+	ipevents_event(IPE_IP_LOCAL_OUT, IPE_GENERIC, skb, NULL, NULL);
 
 	err = __ip6_local_out(skb);
 	if (likely(err == 1))
@@ -101,16 +106,21 @@ static int ip6_output_finish(struct sk_buff *skb)
 	struct dst_entry *dst = skb->dst;
 
 	if (dst->child) {
+		ipevents_event(IPE_IP_FINISH_OUTPUT2, IPE_GENERIC, skb, skb->dst->dev, NULL);
 		skb->dst = dst_pop(skb->dst);
 		return dst_output(skb);
 	}
-
-	if (dst->hh)
-		return neigh_hh_output(dst->hh, skb);
-	else if (dst->neighbour)
-		return dst->neighbour->output(skb);
+	
+	if (dst->hh || dst->neighbour) {
+		ipevents_event(IPE_IP_FINISH_OUTPUT2, IPE_GENERIC, skb, skb->dst->dev, NULL);
+		if (dst->hh)
+			return neigh_hh_output(dst->hh, skb);
+		else if (dst->neighbour)
+			return dst->neighbour->output(skb);
+	}
 
 	IP6_INC_STATS_BH(ip6_dst_idev(dst), IPSTATS_MIB_OUTNOROUTES);
+	ipevents_event(IPE_IP_FINISH_OUTPUT2, IPE_DROPPED, skb, NULL, NULL);
 	kfree_skb(skb);
 	return -EINVAL;
 
@@ -180,6 +190,7 @@ static inline int ip6_skb_dst_mtu(struct sk_buff *skb)
 
 int ip6_output(struct sk_buff *skb)
 {
+	ipevents_event(IPE_IP_FINISH_OUTPUT, IPE_GENERIC, skb, NULL, NULL);
 	if ((skb->len > ip6_skb_dst_mtu(skb) && !skb_is_gso(skb)) ||
 				dst_allfrag(skb->dst))
 		return ip6_fragment(skb, ip6_output2);
@@ -272,6 +283,11 @@ int ip6_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl,
 	if ((skb->len <= mtu) || ipfragok || skb_is_gso(skb)) {
 		IP6_INC_STATS(ip6_dst_idev(skb->dst),
 			      IPSTATS_MIB_OUTREQUESTS);
+		
+		/* the other IPE_IP_LOCAL_OUT is in ip6_local_out() */
+		skb->protocol = htons(ETH_P_IPV6);
+		ipevents_event(IPE_IP_LOCAL_OUT, IPE_GENERIC, skb, NULL, NULL);
+		
 		return NF_HOOK(PF_INET6, NF_INET_LOCAL_OUT, skb, NULL, dst->dev,
 				dst_output);
 	}
@@ -443,6 +459,7 @@ int ip6_forward(struct sk_buff *skb)
 		if (ip6_call_ra_chain(skb, (ptr[2]<<8) + ptr[3]))
 			return 0;
 	}
+	
 
 	/*
 	 *	check and decrement ttl
@@ -535,6 +552,7 @@ int ip6_forward(struct sk_buff *skb)
 	/* Mangling hops number delayed to point after skb COW */
 
 	hdr->hop_limit--;
+	ipevents_event(IPE_IP_FORWARD, IPE_GENERIC, skb, NULL, NULL);
 
 	IP6_INC_STATS_BH(ip6_dst_idev(dst), IPSTATS_MIB_OUTFORWDATAGRAMS);
 	return NF_HOOK(PF_INET6, NF_INET_FORWARD, skb, skb->dev, dst->dev,
@@ -543,6 +561,7 @@ int ip6_forward(struct sk_buff *skb)
 error:
 	IP6_INC_STATS_BH(ip6_dst_idev(dst), IPSTATS_MIB_INADDRERRORS);
 drop:
+	ipevents_event(IPE_IP_FORWARD, IPE_DROPPED, skb, NULL, NULL);
 	kfree_skb(skb);
 	return -EINVAL;
 }
@@ -614,11 +633,14 @@ static int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *))
 	struct rt6_info *rt = (struct rt6_info*)skb->dst;
 	struct ipv6_pinfo *np = skb->sk ? inet6_sk(skb->sk) : NULL;
 	struct ipv6hdr *tmp_hdr;
+	struct sk_buff *original_skb = skb;
 	struct frag_hdr *fh;
 	unsigned int mtu, hlen, left, len;
 	__be32 frag_id = 0;
 	int ptr, offset = 0, err=0;
 	u8 *prevhdr, nexthdr = 0;
+	
+	ipevents_event(IPE_IP_FRAGMENT, IPE_BEFORE, skb, NULL, NULL);
 
 	dev = rt->u.dst.dev;
 	hlen = ip6_find_1stfragopt(skb, &prevhdr);
@@ -730,7 +752,9 @@ static int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *))
 						      sizeof(struct ipv6hdr));
 				ip6_copy_metadata(frag, skb);
 			}
-
+			
+			ipevents_event(IPE_IP_FRAGMENT, IPE_GENERIC, skb, NULL, (void*)original_skb);
+			
 			err = output(skb);
 			if(!err)
 				IP6_INC_STATS(ip6_dst_idev(&rt->u.dst), IPSTATS_MIB_FRAGCREATES);
@@ -747,6 +771,7 @@ static int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *))
 
 		if (err == 0) {
 			IP6_INC_STATS(ip6_dst_idev(&rt->u.dst), IPSTATS_MIB_FRAGOKS);
+			ipevents_event(IPE_IP_FRAGMENT, IPE_AFTER, original_skb, NULL, NULL);
 			dst_release(&rt->u.dst);
 			return 0;
 		}
@@ -851,6 +876,7 @@ slow_path:
 		/*
 		 *	Put this fragment into the sending queue.
 		 */
+		ipevents_event(IPE_IP_FRAGMENT, IPE_GENERIC, frag, NULL, (void*)original_skb);
 		err = output(frag);
 		if (err)
 			goto fail;
@@ -859,6 +885,7 @@ slow_path:
 	}
 	IP6_INC_STATS(ip6_dst_idev(skb->dst),
 		      IPSTATS_MIB_FRAGOKS);
+	ipevents_event(IPE_IP_FRAGMENT, IPE_AFTER, original_skb, NULL, NULL);
 	kfree_skb(skb);
 	return err;
 
diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c
index 1479618..4bf79e6 100644
--- a/net/ipv6/ip6mr.c
+++ b/net/ipv6/ip6mr.c
@@ -49,6 +49,8 @@
 #include <net/addrconf.h>
 #include <linux/netfilter_ipv6.h>
 
+#include <linux/ipevents.h>
+
 struct sock *mroute6_socket;
 
 
@@ -1477,6 +1479,8 @@ static int ip6_mr_forward(struct sk_buff *skb, struct mfc6_cache *cache)
 		}
 		goto dont_forward;
 	}
+	
+	ipevents_event(IPE_IP_MR_FORWARD, IPE_BEFORE, skb, NULL, NULL);
 
 	vif6_table[vif].pkt_in++;
 	vif6_table[vif].bytes_in += skb->len;
@@ -1488,18 +1492,23 @@ static int ip6_mr_forward(struct sk_buff *skb, struct mfc6_cache *cache)
 		if (ipv6_hdr(skb)->hop_limit > cache->mfc_un.res.ttls[ct]) {
 			if (psend != -1) {
 				struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);
-				if (skb2)
+				if (skb2) {
+				    ipevents_event(IPE_IP_MR_FORWARD, IPE_GENERIC, skb2, NULL, (void*)skb);
 					ip6mr_forward2(skb2, cache, psend);
+				}
 			}
 			psend = ct;
 		}
 	}
 	if (psend != -1) {
+		ipevents_event(IPE_IP_MR_FORWARD, IPE_GENERIC, skb, NULL, NULL);
 		ip6mr_forward2(skb, cache, psend);
+		ipevents_event(IPE_IP_MR_FORWARD, IPE_AFTER, skb, NULL, NULL);
 		return 0;
 	}
 
 dont_forward:
+	ipevents_event(IPE_IP_MR_FORWARD, IPE_AFTER, skb, NULL, NULL);
 	kfree_skb(skb);
 	return 0;
 }
diff --git a/net/ipv6/reassembly.c b/net/ipv6/reassembly.c
index a60d7d1..b9216f1 100644
--- a/net/ipv6/reassembly.c
+++ b/net/ipv6/reassembly.c
@@ -56,6 +56,8 @@
 #include <net/addrconf.h>
 #include <net/inet_frag.h>
 
+#include <linux/ipevents.h>
+
 struct ip6frag_skb_cb
 {
 	struct inet6_skb_parm	h;
@@ -451,11 +453,18 @@ err:
 static int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev,
 			  struct net_device *dev)
 {
-	struct sk_buff *fp, *head = fq->q.fragments;
+	struct sk_buff *fp, *iter, *head = fq->q.fragments;
 	int    payload_len;
 	unsigned int nhoff;
 
 	fq_kill(fq);
+	
+	if (prev)
+		head = prev->next;
+	
+	for (iter=fq->q.fragments; iter; iter = iter->next) {
+		ipevents_event(IPE_IP_FRAG_REASM, IPE_BEFORE, iter, NULL, (void*)head);
+	}
 
 	/* Make the one we just received the head. */
 	if (prev) {
@@ -536,6 +545,8 @@ static int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev,
 		head->truesize += fp->truesize;
 		atomic_sub(fp->truesize, &fq->q.net->mem);
 	}
+	
+	ipevents_event(IPE_IP_FRAG_REASM, IPE_AFTER, head, NULL, NULL);
 
 	head->next = NULL;
 	head->dev = dev;
@@ -576,6 +587,7 @@ static int ipv6_frag_rcv(struct sk_buff *skb)
 	struct ipv6hdr *hdr = ipv6_hdr(skb);
 	struct net *net;
 
+	ipevents_event(IPE_IP_DEFRAG, IPE_BEFORE, skb, NULL, NULL);
 	IP6_INC_STATS_BH(ip6_dst_idev(skb->dst), IPSTATS_MIB_REASMREQDS);
 
 	/* Jumbo payload inhibits frag. header */
@@ -621,7 +633,8 @@ static int ipv6_frag_rcv(struct sk_buff *skb)
 		fq_put(fq);
 		return ret;
 	}
-
+	
+	ipevents_event(IPE_IP_DEFRAG, IPE_DROPPED, skb, NULL, NULL);
 	IP6_INC_STATS_BH(ip6_dst_idev(skb->dst), IPSTATS_MIB_REASMFAILS);
 	kfree_skb(skb);
 	return -1;
diff --git a/net/netfilter/core.c b/net/netfilter/core.c
index 292fa28..e69b9ef 100644
--- a/net/netfilter/core.c
+++ b/net/netfilter/core.c
@@ -22,6 +22,8 @@
 #include <net/net_namespace.h>
 #include <net/sock.h>
 
+#include <linux/ipevents.h>
+
 #include "nf_internals.h"
 
 static DEFINE_MUTEX(afinfo_mutex);
@@ -173,6 +175,8 @@ int nf_hook_slow(int pf, unsigned int hook, struct sk_buff *skb,
 		return 1;
 #endif
 
+    ipevents_event(hook, IPE_BEFORE, skb, indev, outdev);
+	
 	/* We may already have this, but read-locks nest anyway */
 	rcu_read_lock();
 
@@ -182,10 +186,14 @@ next_hook:
 			     outdev, &elem, okfn, hook_thresh);
 	if (verdict == NF_ACCEPT || verdict == NF_STOP) {
 		ret = 1;
+		ipevents_event(hook, IPE_AFTER, skb, indev, outdev);
 		goto unlock;
 	} else if (verdict == NF_DROP) {
+		ipevents_event(hook, IPE_DROPPED, skb, indev, outdev);
 		kfree_skb(skb);
 		ret = -EPERM;
+	} else if (verdict == NF_STOLEN) {
+		/* no ipevents_event in this case */
 	} else if ((verdict & NF_VERDICT_MASK) == NF_QUEUE) {
 		if (!nf_queue(skb, elem, pf, hook, indev, outdev, okfn,
 			      verdict >> NF_VERDICT_BITS))
